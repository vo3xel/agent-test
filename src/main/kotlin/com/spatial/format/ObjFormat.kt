package com.spatial.format

import com.spatial.converter.*
import com.spatial.core.*

/**
 * Wavefront OBJ format reader/writer.
 * Supports: vertices (v), normals (vn), faces (f), groups (g), object names (o).
 * Does not support: texture coordinates (vt), materials (mtl), curves.
 */
class ObjReader : FormatReader<Mesh> {
    override val supportedExtensions = setOf("obj")
    
    override fun read(content: String): Result<Mesh> = runCatching {
        val vertices = mutableListOf<Point3D>()
        val normals = mutableListOf<Vector3D>()
        val faces = mutableListOf<Face>()
        var objectName = ""
        
        content.lineSequence()
            .map { it.trim() }
            .filter { it.isNotEmpty() && !it.startsWith("#") }
            .forEach { line ->
                val parts = line.split(WHITESPACE_REGEX)
                when (parts[0]) {
                    "v" -> vertices.add(parseVertex(parts))
                    "vn" -> normals.add(parseNormal(parts))
                    "f" -> faces.add(parseFace(parts))
                    "o" -> objectName = parts.getOrElse(1) { "" }
                }
            }
        
        Mesh(
            vertices = vertices,
            faces = faces,
            normals = normals,
            metadata = MeshMetadata(name = objectName, sourceFormat = "obj")
        )
    }
    
    private fun parseVertex(parts: List<String>): Point3D {
        require(parts.size >= 4) { "Vertex requires x, y, z coordinates" }
        return Point3D(
            parts[1].toDouble(),
            parts[2].toDouble(),
            parts[3].toDouble()
        )
    }
    
    private fun parseNormal(parts: List<String>): Vector3D {
        require(parts.size >= 4) { "Normal requires x, y, z components" }
        return Vector3D(
            parts[1].toDouble(),
            parts[2].toDouble(),
            parts[3].toDouble()
        )
    }
    
    private fun parseFace(parts: List<String>): Face {
        // OBJ face indices are 1-based, can be v, v/vt, v/vt/vn, or v//vn
        val indices = parts.drop(1).map { faceVertex ->
            val vertexIndex = faceVertex.split("/")[0].toInt()
            vertexIndex - 1  // Convert to 0-based
        }
        return Face(indices)
    }
    
    companion object {
        private val WHITESPACE_REGEX = "\\s+".toRegex()
    }
}

class ObjWriter : FormatWriter<Mesh> {
    override val supportedExtensions = setOf("obj")
    
    override fun write(data: Mesh): Result<String> = runCatching {
        buildString {
            appendLine("# Generated by spatial-converter")
            if (data.metadata.name.isNotEmpty()) {
                appendLine("o ${data.metadata.name}")
            }
            appendLine()
            
            // Vertices
            for (v in data.vertices) {
                appendLine("v ${v.x} ${v.y} ${v.z}")
            }
            appendLine()
            
            // Normals
            for (n in data.normals) {
                appendLine("vn ${n.x} ${n.y} ${n.z}")
            }
            if (data.normals.isNotEmpty()) appendLine()
            
            // Faces (1-based indices)
            for (face in data.faces) {
                val indices = face.indices.joinToString(" ") { (it + 1).toString() }
                appendLine("f $indices")
            }
        }
    }
}
